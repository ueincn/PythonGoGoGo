**类**

类把数据与功能绑定在一起。创建新类就是创建新的对象 **类型**，从而创建该类型的新 **实例** 。类实例支持维持自身状态的属性，还支持（由类定义的）修改自身状态的方法。

- 根据约定，在Python中，首字母大写的名称指的是类。这个类定义中的括号是空的，因为我们要从空白创建这个类。
- 面向对象编程 是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。
- 编写类时，你定义一大类对象都有的通用行为。基于类创建对象 时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。
- 类中的函数称为方法。
- `__init__()` 是一个特殊的方法，每当你根据类创建新实例时，Python都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。在这个方法的定义中，形参self 必不可少，还必须位于其他形参的前面。
- Python调用这个`__init__()`方法来创建实例时，将自动传入实参`self` 。每个与类相关联的方法调用都自动传递实参`self` ，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。
- 要访问实例的属性，可使用句点表示法.
- 类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法`__init__()`内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参。
- 可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行递增（增加特定的值）。
- 类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。
- 对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文档字符串，对其中的类可用于做什么进行描述。可使用空行来组织代码，但不要滥用。在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的import 语句，再添加一个空行，然后编写导入你自己编写的模块的import 语句。在包含多条import 语句的程序中，这种做法让人更容易明白程序使用的各个模块都来自何方。
#### 继承

- 编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承 。
- 一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；
- 原有的类称为父类 ，而新类称为子类 。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。
- 创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法`__init__()`需要父类施以援手。
- 创建子类时，父类必须包含在当前文件中，且位于子类前面。
- 定义子类时，必须在括号内指定父类的名称。
- `super() `是一个特殊函数，帮助Python将父类和子类关联起来。父类也称为超类 （superclass），名称super因此而得名。
- 函数`super()` 需要两个实参：子类名和对象self 。为帮助Python将父类和子类关联起来，这些实参必不可少。
- 让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法。
- 对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。
#### 导入类

- 导入类是一种有效的编程方式。
- 虽然同一个模块中的类之间应存在某种相关性，但可根据需要在一个模块中存储任意数量的类。
- 可根据需要在程序文件中导入任意数量的类。你还可以导入整个模块，再使用句点表示法访问需要的类。这种导入方法很简单，代码也易于阅读。由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。
- 导入模块中的所有类。
   - 要导入模块中的每个类，可使用下面的语法：

        `from module_name import *`

   - 不推荐使用这种导入方式，其原因有二。首先，如果只要看一下文件开头的import 语句，就能清楚地知道程序使用了哪些类，将大有裨益；但这种导入方式没有明确地指出你
   - 使用了模块中的哪些类。这种导入方式还可能引发名称方面的困惑。如果你不小心导入了一个与程序文件中其他东西同名的类，将引发难以诊断的错误。
- 有时候，需要将类分散到多个模块中，以免模块太大，或在同一个模块中存储不相关的类。将类存储在多个模块中时，你可能会发现一个模块中的类依赖于另一个模块中的类。在这种情况下，可在前一个模块中导入必要的类。